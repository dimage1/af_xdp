DONE

	Sketch out client and server programs

	Update makefile and get it building and linking on linux

	Read AF_XDP resources:

		https://medium.com/high-performance-network-programming/recapitulating-af-xdp-ef6c1ebead8				<--- really good
		https://www.kernel.org/doc/html/latest/networking/af_xdp.html
		https://github.com/xdp-project/xdp-tutorial/tree/master/advanced03-AF_XDP
		https://github.com/gamemann/XDP-Stats/tree/master/src/af_xdp
		https://github.com/xdp-project/bpf-examples/tree/master/AF_XDP-forwarding
		https://networkbuilders.intel.com/docs/networkbuilders/af-xdp-sockets-high-performance-networking-for-cloud-native-networking-technology-guide.pdf

	Find the name of the interface on hulk for the 10G NIC... 

		enp8s0f0

	Get the reflector server running on hulk linux box with the 10G NIC. Disable logging so it's performant.

	Set to only one RSS queue for now:

		sudo ethtool -L enp8s0f0 combined 4
		sudo ethtool -l enp8s0f0

	Setup vision linux box so it's ready to go

	Modify client so it has hard coded interface name

	Get the server IP address and port hardcoded in the client

		192.168.183.124:40000

	Sketch out the client as required to work with AF_XDP packets

	Following tutorial here: https://github.com/xdp-project/xdp-tutorial/tree/master/advanced03-AF_XDP

	Packet buffer is created.

	umem is created.

	Cleanup for buffer and umem.

	Create the xsk map in the xdp program and grab file handle in userspace

	Create the xsk socket

	Clean up the xsk socket on destroy

	Direct RSS to queue 0

		sudo ethtool -N enp8s0f0 flow-type udp4 action 0

    Wrap my head around exactly what is going on with the ring buffers

    The example code shows a system which processes received packets, and if valid, responds 1:1 with a packet.

    As such it's a system driven by packet receives, it reuses the frame for the received packet when it sends a response.

    My system needs to be different, it's about sending packets. The actual receives could be done inside the xdp program (and probably should)

    In a future article I could write an example that combines sending and receiving.

    This example would just demonstrate how to do the sends?

    The receives are done in batches, which seems like a concern when the system may only have one client connected to it: RX_BATCH_SIZE

	Study the simple allocator. What exactly are they doing? It seems overly simplistic...

	If I'm not allowing receives through the system, then I can drive by sends -- this could simplify the allocation of frames?

	arp command on linux to get arp table (address resolution protocol, eg. get ethernet address for given ip address)

	https://www.geeksforgeeks.org/arp-command-in-linux-with-examples/?ref=lbp

	Work out strategy to send packets. 

	I think it can just be a rolling index modulo MAX_FRAMES?

	Stop if the current frame is not completed yet.

	Need to implement completion for sends to mark frames as free to use for send.

	Doesn't seem hard.

	Actually, it seems that the way the stuff works is that you have an array of free frames.

	You setup these free frames initially, and when you have sends complete, you add the frame back into the free array.

	I think the way the APIs work, they require passing in the free frames array -- otherwise, I'd use the rolling index

	Double check this...

	This code does the simple array of free frames

		static uint64_t xsk_alloc_umem_frame(struct xsk_socket_info *xsk)
		{
		    uint64_t frame;
		    if (xsk->umem_frame_free == 0)
		        return INVALID_UMEM_FRAME;

		    frame = xsk->umem_frame_addr[--xsk->umem_frame_free];
		    xsk->umem_frame_addr[xsk->umem_frame_free] = INVALID_UMEM_FRAME;
		    return frame;
		}

		static void xsk_free_umem_frame(struct xsk_socket_info *xsk, uint64_t frame)
		{
		    assert(xsk->umem_frame_free < NUM_FRAMES);

		    xsk->umem_frame_addr[xsk->umem_frame_free++] = frame;
		}

		static uint64_t xsk_umem_free_frames(struct xsk_socket_info *xsk)
		{
		    return xsk->umem_frame_free;
		}

	It's simple enough. Adapted it and moving on.

	Get everything compiling, linking and running.

	Actually construct the packet to send.

	Construct ethernet header

	Construct ip header

	Construct udp header

	Get ipv4 checksum working

TODO

	Pin client to run on core 0.

	----------

	Instead of constructing a single packet, I should construct a batch of packets to send, eg. grab all the free frames for send, iterate across, and gen them in one go

	And then make one syscall to send them
		
	----------

	Verify I receive the packets on the server-side.

	----------

	Verify that I receive packets from the server on the client (reflected)

	----------

	Implement stats:

		Number of packets sent on client (drive from AF_XDP)

		Number of packets received on client (drive from XDP program)

	----------
