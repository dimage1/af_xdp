DONE

	Sketch out client and server programs

	Update makefile and get it building and linking on linux

	Read AF_XDP resources:

		https://medium.com/high-performance-network-programming/recapitulating-af-xdp-ef6c1ebead8				<--- really good
		https://www.kernel.org/doc/html/latest/networking/af_xdp.html
		https://github.com/xdp-project/xdp-tutorial/tree/master/advanced03-AF_XDP
		https://github.com/gamemann/XDP-Stats/tree/master/src/af_xdp
		https://github.com/xdp-project/bpf-examples/tree/master/AF_XDP-forwarding
		https://networkbuilders.intel.com/docs/networkbuilders/af-xdp-sockets-high-performance-networking-for-cloud-native-networking-technology-guide.pdf

	Find the name of the interface on hulk for the 10G NIC... 

		enp8s0f0

	Get the reflector server running on hulk linux box with the 10G NIC. Disable logging so it's performant.

	Set to only one RSS queue for now:

		sudo ethtool -L enp8s0f0 combined 1
		sudo ethtool -l enp8s0f0

	Setup vision linux box so it's ready to go

	Modify client so it has hard coded interface name

	Get the server IP address and port hardcoded in the client

		192.168.183.124:40000

	Sketch out the client as required to work with AF_XDP packets

	Following tutorial here: https://github.com/xdp-project/xdp-tutorial/tree/master/advanced03-AF_XDP

	Packet buffer is created.

	umem is created.

	Cleanup for buffer and umem.

	Create the xsk map in the xdp program and grab file handle in userspace

	Create the xsk socket

	Clean up the xsk socket on destroy

	Direct RSS to queue 0

		sudo ethtool -N enp8s0f0 flow-type udp4 action 0

    Wrap my head around exactly what is going on with the ring buffers

    The example code shows a system which processes received packets, and if valid, responds 1:1 with a packet.

    As such it's a system driven by packet receives, it reuses the frame for the received packet when it sends a response.

    My system needs to be different, it's about sending packets. The actual receives could be done inside the xdp program (and probably should)

    In a future article I could write an example that combines sending and receiving.

    This example would just demonstrate how to do the sends?

    The receives are done in batches, which seems like a concern when the system may only have one client connected to it: RX_BATCH_SIZE

	Study the simple allocator. What exactly are they doing? It seems overly simplistic...

	If I'm not allowing receives through the system, then I can drive by sends -- this could simplify the allocation of frames?

	arp command on linux to get arp table (address resolution protocol, eg. get ethernet address for given ip address)

	https://www.geeksforgeeks.org/arp-command-in-linux-with-examples/?ref=lbp

	Work out strategy to send packets. 

	I think it can just be a rolling index modulo MAX_FRAMES?

	Stop if the current frame is not completed yet.

	Need to implement completion for sends to mark frames as free to use for send.

	Doesn't seem hard.

	Actually, it seems that the way the stuff works is that you have an array of free frames.

	You setup these free frames initially, and when you have sends complete, you add the frame back into the free array.

	I think the way the APIs work, they require passing in the free frames array -- otherwise, I'd use the rolling index

	Double check this...

	This code does the simple array of free frames

		static uint64_t xsk_alloc_umem_frame(struct xsk_socket_info *xsk)
		{
		    uint64_t frame;
		    if (xsk->umem_frame_free == 0)
		        return INVALID_UMEM_FRAME;

		    frame = xsk->umem_frame_addr[--xsk->umem_frame_free];
		    xsk->umem_frame_addr[xsk->umem_frame_free] = INVALID_UMEM_FRAME;
		    return frame;
		}

		static void xsk_free_umem_frame(struct xsk_socket_info *xsk, uint64_t frame)
		{
		    assert(xsk->umem_frame_free < NUM_FRAMES);

		    xsk->umem_frame_addr[xsk->umem_frame_free++] = frame;
		}

		static uint64_t xsk_umem_free_frames(struct xsk_socket_info *xsk)
		{
		    return xsk->umem_frame_free;
		}

	It's simple enough. Adapted it and moving on.

	Get everything compiling, linking and running.

	Actually construct the packet to send.

	Construct ethernet header

	Construct ip header

	Construct udp header

	Get ipv4 checksum working

	Pin client to run on core 0.

	Instead of constructing a single packet, I should construct a batch of packets to send, eg. grab all the free frames for send, iterate across, and gen them in one go

	And then make one syscall to send them

	Set the batch size to be configurable. Default it to 256.
		
	Verify that the server receives packets sent from the client.

	Verify that the client receives reflected packets back from the server

	Number of packets sent on client (drive from AF_XDP) -- atomic

	Number of packets received on client (drive from XDP program) -- atomic

	Create a stats thread

	Print out stats once per-second on stats thread.

	I can send more than 1 million packets per-second from a single core on vision. Pretty amazing!

	Debug why not seeing packets back from server

	Server is receiving packets from the client

	It thinks it is reflecting them

	The client isn't logging any packets received back from server -- but this used to be working. What's going on?

	It looks like the interface isn't getting any packets sent back to it from the server. What's wrong?

	ifconfig

		enp8s0f0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
	        inet 192.168.183.121  netmask 255.255.255.0  broadcast 192.168.183.255
	        inet6 fe80::7a32:17d5:df24:24fd  prefixlen 64  scopeid 0x20<link>
	        ether a0:36:9f:68:eb:98  txqueuelen 1000  (Ethernet)
	        RX packets 0  bytes 0 (0.0 B)
	        RX errors 239  dropped 0  overruns 0  frame 239
	        TX packets 346637  bytes 49221386 (49.2 MB)
	        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

	Could it be because I don't have the receive queues setup? I remember it used to work, but this was before I simplified.

	Don't think so.

	Try dropping send batch size to 1...

	Remove reflection. It's not necessary for this example.

	Put received packet stats on the server side.

TODO

	Convert stats to accum version so we can see sent and received per-second.

	------------

	Move the current version to 001, write a README.md

	------------

	Create a 002

	You can lie about what address packets are coming from

	This means I can spoof multiple source client addresses, as long as I take care to always respond to the real (hardcoded) client address, it will work.

	This should distribute packet sends across multiple receive queues on the server

	------------

	The same lie needs to be done by the server -> client on reflecting the packet. lie about the source address

	Then the client will also receive packets across all receive queues

	------------
