DONE

	Sketch out client and server programs

	Update makefile and get it building and linking on linux

	Read AF_XDP resources:

		https://medium.com/high-performance-network-programming/recapitulating-af-xdp-ef6c1ebead8				<--- really good
		https://www.kernel.org/doc/html/latest/networking/af_xdp.html
		https://github.com/xdp-project/xdp-tutorial/tree/master/advanced03-AF_XDP
		https://github.com/gamemann/XDP-Stats/tree/master/src/af_xdp
		https://github.com/xdp-project/bpf-examples/tree/master/AF_XDP-forwarding
		https://networkbuilders.intel.com/docs/networkbuilders/af-xdp-sockets-high-performance-networking-for-cloud-native-networking-technology-guide.pdf

	Find the name of the interface on hulk for the 10G NIC... 

		enp8s0f0

	Get the reflector server running on hulk linux box with the 10G NIC. Disable logging so it's performant.

	Set to only one RSS queue for now:

		sudo ethtool -L enp8s0f0 combined 4
		sudo ethtool -l enp8s0f0

	Setup vision linux box so it's ready to go

	Modify client so it has hard coded interface name

	Get the server IP address and port hardcoded in the client

		192.168.183.124:40000

	Sketch out the client as required to work with AF_XDP packets

	Following tutorial here: https://github.com/xdp-project/xdp-tutorial/tree/master/advanced03-AF_XDP

	Packet buffer is created.

	umem is created.

	Cleanup for buffer and umem.

	Create the xsk map in the xdp program and grab file handle in userspace

	Create the xsk socket

	Clean up the xsk socket on destroy

	Direct RSS to queue 0

		sudo ethtool -N enp8s0f0 flow-type udp4 action 0

    Wrap my head around exactly what is going on with the ring buffers

    The example code shows a system which processes received packets, and if valid, responds 1:1 with a packet.

    As such it's a system driven by packet receives, it reuses the frame for the received packet when it sends a response.

    My system needs to be different, it's about sending packets. The actual receives could be done inside the xdp program (and probably should)

    In a future article I could write an example that combines sending and receiving.

    This example would just demonstrate how to do the sends?

    The receives are done in batches, which seems like a concern when the system may only have one client connected to it: RX_BATCH_SIZE

	Study the simple allocator. What exactly are they doing? It seems overly simplistic...

	If I'm not allowing receives through the system, then I can drive by sends -- this could simplify the allocation of frames?

	arp command on linux to get arp table (address resolution protocol, eg. get ethernet address for given ip address)

	https://www.geeksforgeeks.org/arp-command-in-linux-with-examples/?ref=lbp

	Work out strategy to send packets. 

	I think it can just be a rolling index modulo MAX_FRAMES?

	Stop if the current frame is not completed yet.

	Need to implement completion for sends to mark frames as free to use for send.

	Doesn't seem hard.

	Actually, it seems that the way the stuff works is that you have an array of free frames.

	You setup these free frames initially, and when you have sends complete, you add the frame back into the free array.

	I think the way the APIs work, they require passing in the free frames array -- otherwise, I'd use the rolling index

	Double check this...

	This code does the simple array of free frames

		static uint64_t xsk_alloc_umem_frame(struct xsk_socket_info *xsk)
		{
		    uint64_t frame;
		    if (xsk->umem_frame_free == 0)
		        return INVALID_UMEM_FRAME;

		    frame = xsk->umem_frame_addr[--xsk->umem_frame_free];
		    xsk->umem_frame_addr[xsk->umem_frame_free] = INVALID_UMEM_FRAME;
		    return frame;
		}

		static void xsk_free_umem_frame(struct xsk_socket_info *xsk, uint64_t frame)
		{
		    assert(xsk->umem_frame_free < NUM_FRAMES);

		    xsk->umem_frame_addr[xsk->umem_frame_free++] = frame;
		}

		static uint64_t xsk_umem_free_frames(struct xsk_socket_info *xsk)
		{
		    return xsk->umem_frame_free;
		}

TODO

	

















































	--------------

	Count how many packets per-second are being sent, and how many are being received.

	Print out out once per-second.

	Is it possible to spread packets across multiple RSS queues without having 64 machines?

	Verify I can receive millions of reflected packets...
